# 加入浮点Float

wth 2022.7.31

------

比赛树莓派用的是armhf内核（32位支持hard float的内核）

（比赛要求汇编是32位arm V7）

使用hard float会有很大的性能优势，使用硬件FPU去执行。

也就是使用大量的浮点指令！

VFP：Vector Floating Point

### 浮点常量

有普通十进制浮点常量和十六进制浮点常量两种。

不考虑任何后缀（如f，l，F，L）。

atof函数处理不了十六进制浮点的情况，需要自己处理。

### 培训内容

1. 浮点数结果的精度是否会特判？可能会存在一些误差。

并不要求完全一致，可以有一点误差。还没定，可能是10-4或10-6。

如果调整指令顺序（例如表达式中），可能出现大数吃小数的情况。

所以浮点代码不建议做指令顺序调整。

2. neon指令，会有一点问题（不遵循IEEE标准）

也会在测例上下功夫，避免出现大量的误差。

从工业角度，需要细分场景考虑（例如科学计算）。

### 具体实现

（使用软浮点就需要调用一些abi，即the floating point helper functions。

最大的问题：哪些情况下需要考虑隐式类型转换？

比如数组初始化？int和float相加？）（可忽略）

**重要**：

修改了Temp的定义，加入了isFloat属性和ctvalf用于存放编译时刻静态值。（需要后端翻译TAC时检测一下Temp的isFloat属性，看看是不是浮点）。

加入了genLoadImm4F用于浮点立即数赋值。LoadImm4F这是一条新的TAC，需要后端支持一下。

对于全局变量，新增加了两种类型（Piece的类型），分别是GLOBALF（全局浮点）和GLOARRF（全局浮点数组）。需要后端对该两种情况进行翻译。

### 参考资料

教程：arm浮点  [arm浮点运算 - 走看看 (zoukankan.com)](http://t.zoukankan.com/-9-8-p-9254964.html)

编译参数： [CMake: (一) arm浮点编译参数 - 采男孩的小蘑菇 - 博客园 (cnblogs.com)](https://www.cnblogs.com/flyinggod/p/13713183.html)

### 后端实现(TODO)

1. 见上面的具体实现部分
2. 隐式转换

目前隐式类型转换完全交给后端来做！！！

后端在翻译相应TAC时需要检测操作的Temp的类型（通过isFloat属性），根据情况使用转换指令来转换。

这些TAC包括：assign，store，load，加减乘除，比较（大于小于和相等比较）。