# SysY分析

wth 2022.4.20

------

## 一. 文法分析

### 1.开始符号

**CompUnit**为开始符号，由若干**声明**和**函数定义**构成。其中声明又分为**常量声明**和**变量声明**。

### 2.常量声明

常量声明：const BType和大于等于1个**ConstDef**（常数定义）。

这里的常数定义**ConstDef**，可以是数组类型，且必须带初始值，形如：

`ConstDef → Ident { '[' ConstExp ']' } '=' ConstInitVal`

注意：数组[ ]之间的必须是常量表达式！不支持VLA。

**ConstInitVal**即常量初值可以是常量表达式，也可以是常量初值用{ }构成的嵌套（对应多维数组的情况）。

**ConstExp**与普通**Exp**看上去没差别，但语义上要求里面出现的**Ident**必须是常量。

### 3.变量声明

变量声明类似常量，区别是：可以不用带初始值。

### 4.函数定义

函数定义形如：

`FuncDef → FuncType Ident '(' [FuncFParams] ')' Block`

注意：SysY中没有函数声明这种东西，只能函数定义。

函数形参**FuncFParam**中若形参是数组，第一维长度可以空缺，形如：

`FuncFParam → BType Ident ['[' ']' { '[' Exp ']' }]`

问题：这里有疑问，按照规则第一维长度必须空缺吗？

答：目前看来应该是的！

### 5.Block语句块

**Block**由若干个**BlockItem**构成，每个**BlockItem**可以是**Decl**即声明或**Stmt**即语句。

语句**Stmt**有多种情况：

1. 左值 = 表达式
2. [表达式] ；
3. Block
4. if语句
5. while语句
6. break
7. continue
8. return [表达式] ；

### 6.表达式

左值表达式**LVal**形如：

`LVal → Ident {'[' Exp ']'}`

顾名思义，它能出现在赋值语句的左边，即它是某个变量或某个数组元素。

基本表达式**PrimaryExp**可以是(Exp)或LVal或数字，它是各种表达式的最小单元。

在它基础上能不断构造：一元表达式，乘除模表达式，加减表达式，关系表达式，相等性表达式，逻辑与表达式，逻辑或表达式。（根据优先级从前往后排列）

## 二. 终结符特征

### 1.标识符Ident

同名标识符的约定：

1. 全局变量和局部变量的作用域可以重叠，重叠部分局部变量优先；

2. 同名局部变量的作用域不能重叠；

3. SysY 语言中变量名可以与函数名相同。

### 2.注释

单行注释：//

多行注释（块注释）：/*   我是注释，我摊牌了    */

### 3.数值常量

三种类型：十进制，八进制，十六进制

注意：单独的0属于八进制

疑问：是否要考虑 _ ，目前看好像不用。

## 三. 语义约束

### 1.程序

程序由单个文件组成，必须存在且仅存在一个标识为 ‘main’ 、无参数、返回类 型为 int 的 FuncDef(函数定义)。

### 2.常量变量定义

数组索引 [ ]中的表达式必须在编译时求值到**非负整数**。

问题：如何去处理等于0时的情况，减少一维吗？

注意：处理**隐式初始化**，例如 = { }填充0。（较复杂详见手册）

注意：对于全局变量，指定的初值表达式必须是常量表达式。

注意：对于**未显示初始化的全局变量**，记得要初始化为0。

### 3.函数定义

数组作为函数形参时：

1. **第一维长度省略，直接用 [ ]表示；**

2. 其他维长度用常量表示。

数组作为函数实参时：类型是Exp类型

例：对于二维数组a，可以传a[1]作为一维数组，用int[]接收。

提示：形参接收的实际是实参数组的地址。

### 4.语句

单个的Exp可以作为一个语句，它会被求值然后丢弃。

Exp在SysY中是int型表达式，但里面不能出现`！`，`！`只能在Cond即条件表达式中出现。

LVal 必须是当前作用域内、该 Exp 语句之前有定义的变量或常量；对于赋值号左边的 LVal 必须是变量。

## 四. 关于浮点

今年比赛会引入浮点float类型。

这意味着不仅要加个BType，还要去考虑一些类型转换的问题。

浮点计算的效率也会影响最终的性能。

这一部分待补充，或者开个新的章节专门讨论。