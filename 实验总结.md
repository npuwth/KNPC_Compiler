# 实验总结
## 实验进度
`目前实现了以下功能`
1. 定义变量 int array
2. 变量赋值 int array
3. 全局变量
4. 常量const
5. 循环语句while
6. 分支语句if
7. 函数定义
8. 函数调用
9. SysY系统库函数

目前通过了SysY2021的103个功能测试
## 项目结构
```
├── 3rdparty
│   ├── hash.hpp
│   ├── hash_fun.hpp
│   ├── hash_iterator.hpp
│   ├── hash_map.hpp
│   ├── hash_table.hpp
│   ├── list.hpp
│   ├── map.hpp
│   ├── set.hpp
│   ├── stack.hpp
│   └── vector.hpp
├── backend
│   └── asm
│       ├── arm_frame_manager.cpp
│       ├── arm_frame_manager.hpp
│       ├── arm_md.cpp
│       ├── arm_md.hpp
│       ├── mach_desc.hpp
│       ├── offset_counter.cpp
│       └── offset_counter.hpp
├── frontend
│   ├── parser
│   │   ├── SysY.g4
│   │   ├── SysY.interp
│   │   ├── SysY.tokens
│   │   ├── SysYBaseVisitor.cpp
│   │   ├── SysYBaseVisitor.h
│   │   ├── SysYLexer.cpp
│   │   ├── SysYLexer.h
│   │   ├── SysYLexer.interp
│   │   ├── SysYLexer.tokens
│   │   ├── SysYParser.cpp
│   │   ├── SysYParser.h
│   │   ├── SysYVisitor.cpp
│   │   └── SysYVisitor.h
│   ├── scope
│   │   ├── func_scope.cpp
│   │   ├── global_scope.cpp
│   │   ├── local_scope.cpp
│   │   ├── scope.cpp
│   │   ├── scope.hpp
│   │   ├── scope_stack.cpp
│   │   └── scope_stack.hpp
│   ├── symb
│   │   ├── function.cpp
│   │   ├── symbol.cpp
│   │   ├── symbol.hpp
│   │   └── variable.cpp
│   ├── tac
│   │   ├── dataflow.cpp
│   │   ├── flow_graph.cpp
│   │   ├── flow_graph.hpp
│   │   ├── tac.cpp
│   │   ├── tac.hpp
│   │   ├── trans_helper.cpp
│   │   └── trans_helper.hpp
│   ├── translation
│   │   ├── generate_ir.cpp
│   │   └── generate_ir.hpp
│   └── type
│       ├── array_type.cpp
│       ├── base_type.cpp
│       ├── func_type.cpp
│       ├── type.cpp
│       └── type.hpp
├── main.cpp
├── optimizer
│   ├── pass.hpp
│   └── ssa.cpp
└── util
    ├── config.hpp
    ├── define.hpp
    ├── error.cpp
    ├── error.hpp
    ├── errorbuf.hpp
    ├── location.hpp
    ├── misc.cpp
    ├── options.cpp
    └── options.hpp
```
## 前端
前端的语法分析和词法分析使用Antlr工具完成，通过Antlr生成语法分析树通过遍历语法分析树生成中间IR（四元式）
在前端分为：
1. parser：实现词法和语法分析规则xxx.g4，由Antlr生成相应代码
2. scope：作用域，分为函数作用域，全局作用域，局部作用域以及堆栈作用域共同继承自scope类
```cpp
class Scope {
  protected:
    // the underlying map
    std::unordered_map<std::string, symb::Symbol *> _syms;

  public:
    // kind of the scopes
    typedef enum { GLOBAL, FUNCTION, LOCAL } kind_t;

    // the iterator type
    typedef ScopeIterator iterator;
    // Gets the scope kind
    virtual kind_t getKind(void) = 0;
    // Tests whether it is a global scope
    virtual bool isGlobalScope(void);
    // Tests whether it is a function scope
    virtual bool isFuncScope(void);
    // Looks up a name in this scope
    virtual symb::Symbol *lookup(std::string);
    // Declares a symbol in this scope
    virtual void declare(symb::Symbol *);
    // Cancels an already-declared symbol in this scope
    virtual void cancel(symb::Symbol *);
    // Gets the begin iterator
    virtual iterator begin(void);
    // Gets the beyond-last iterator
    virtual iterator end(void);
    // Prints the content of this scope
    virtual void dump(std::ostream &) = 0;

    virtual ~Scope() {}
};
```
3. symb：符号表，包括变量和函数。共同继承自Symbol
```cpp
    class Symbol {
  protected:
    // name of this symbol
    std::string name;
    // type of this symbol
    type::Type *type;
    // the scope where this symbol is defined
    scope::Scope *defined_in;
    // the order of this symbol
    int order;

  public:
    // auxiliary mark
    int mark;
    // offset of this symbol
    int offset;
    // Gets the name of this symbol
    virtual std::string getName(void);
    // Gets the type of this symbol
    virtual type::Type *getType(void);
    // Gets the order
    virtual int getOrder(void);
    // Sets the order
    virtual void setOrder(int order);
    // Tests whether it is a Variable
    virtual bool isVariable(void);
    // Tests whether it is a Function
    virtual bool isFunction(void);
    // Gets the scope where this symbol was declared
    virtual scope::Scope *getScope(void);
    // Sets the scope of this symbol
    virtual void setScope(scope::Scope *);
    // Prints this symbol
    virtual void dump(std::ostream &) = 0;

    virtual ~Symbol() {}
};
```
4. tac：中间IR，在这部分，我们使用四元式，这部分包括四元式的数据结构的定义，CFG的实现以及代码的活跃性分析。
```cpp
typedef struct TempVariable
    {
        int id;               // 临时变量的编号
        int size;             // 所占字节数
        bool is_offset_fixed; // 临时变量是否被分配空间
        int offset;           // FP寄存器的偏移量
        int ctval;            // 编译时刻的静态值
        bool isConst;         // 是否常量
        int reg;
    } * Temp;

    typedef struct LabelObject
    {
        int id;               // Label的编号
        std::string str_form; // Label的string形式
        bool target;          // 是否是目标Label
        Tac *where;           // The TAC which marks this Label (for dataflow analysis)
    } * Label;
    
    typedef struct FunctyObject
    {
        Label entry;        // 函数的入口Label
        Tac *code;          // 函数所对应的TAC
    } * Functy;

    typedef struct GlobalObject
    {
        std::string name;   //全局变量名
        int value;          //全局变量值
        int size;           //所占大小
        bool isConst;       //是否常量
    } * GlobalVar;

    typedef struct GlobalArray
    {
        std::string name;   //全局变量名
        util::Vector<int> values;//全局变量值
        int size;           //所占大小
        bool isConst;       //是否常量
    } * GlobalArr;
```
5. translation：这部分实现IR的翻译，继承自SysYBaseVisitor通过遍历语法分析树生成IR
6. type：定义基本数据类型
```cpp
class Type {
  public:
    // Tests whether this type is BaseType
    virtual bool isBaseType(void);
    // Tests whether this type is ArrayType
    virtual bool isArrayType(void);
    // Tests whether this type is FuncType
    virtual bool isFuncType(void);
    // Get the size of this type
    virtual int getSize() { return 0; }
    // Tests whether this type is compatible with the given type
    // NOTE:
    //   if "a <- b" is legal, then type(b) is compatible with type(a)
    virtual bool compatible(Type *) = 0;
    // Tests whether this type is equal to the given type
    virtual bool equal(Type *) = 0;
    // Prints this type
    virtual void dump(std::ostream &) = 0;

    virtual ~Type() {}
};

```
## 后端
1. 基于线性扫描的寄存器分配算法
2. 基于图着色的寄存器分配算法
## 优化
1. 静态单赋值形式（SSA）
学习tarjan的支配树算法，将基本块转化成支配树，并插入$phi$函数
2. 常量折叠
针对常量、常量表达式直接用编译时计算出的值进行替换。
针对一些布尔表达式（如false&&x、true||y）直接替换。